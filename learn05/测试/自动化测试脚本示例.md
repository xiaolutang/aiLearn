# 智能教学助手自动化测试脚本示例

## 1. 自动化测试框架概述

### 1.1 技术栈选择
- **前端UI自动化**：Selenium WebDriver + Python
- **API自动化测试**：pytest + requests
- **移动端自动化**：Appium + Python
- **性能测试**：Locust + Python
- **测试报告**：Allure Report
- **CI/CD集成**：GitHub Actions / Jenkins

### 1.2 项目结构
```
automation_tests/
├── config/
│   ├── __init__.py
│   ├── settings.py
│   └── test_data.py
├── pages/
│   ├── __init__.py
│   ├── base_page.py
│   ├── login_page.py
│   ├── grade_management_page.py
│   └── dashboard_page.py
├── tests/
│   ├── ui_tests/
│   │   ├── __init__.py
│   │   ├── test_login.py
│   │   ├── test_grade_management.py
│   │   └── test_dashboard.py
│   ├── api_tests/
│   │   ├── __init__.py
│   │   ├── test_auth_api.py
│   │   ├── test_grade_api.py
│   │   └── test_analysis_api.py
│   └── performance_tests/
│       ├── __init__.py
│       ├── load_test.py
│       └── stress_test.py
├── utils/
│   ├── __init__.py
│   ├── driver_manager.py
│   ├── test_helpers.py
│   └── data_generator.py
├── requirements.txt
├── pytest.ini
└── README.md
```

## 2. 配置文件

### 2.1 settings.py - 测试配置
```python
# config/settings.py
import os
from dataclasses import dataclass
from typing import Dict, Any

@dataclass
class TestConfig:
    """测试配置类"""
    
    # 环境配置
    BASE_URL: str = os.getenv('TEST_BASE_URL', 'http://localhost:3000')
    API_BASE_URL: str = os.getenv('API_BASE_URL', 'http://localhost:8000/api')
    
    # 浏览器配置
    BROWSER: str = os.getenv('BROWSER', 'chrome')
    HEADLESS: bool = os.getenv('HEADLESS', 'false').lower() == 'true'
    IMPLICIT_WAIT: int = 10
    EXPLICIT_WAIT: int = 20
    
    # 测试数据配置
    TEST_DATA_PATH: str = 'config/test_data.json'
    SCREENSHOT_PATH: str = 'screenshots'
    REPORT_PATH: str = 'reports'
    
    # 数据库配置
    DB_HOST: str = os.getenv('DB_HOST', 'localhost')
    DB_PORT: int = int(os.getenv('DB_PORT', '3306'))
    DB_NAME: str = os.getenv('DB_NAME', 'test_ailearn')
    DB_USER: str = os.getenv('DB_USER', 'test_user')
    DB_PASSWORD: str = os.getenv('DB_PASSWORD', 'test_password')
    
    # API认证配置
    API_KEY: str = os.getenv('API_KEY', '')
    JWT_SECRET: str = os.getenv('JWT_SECRET', 'test_secret')
    
    # 性能测试配置
    LOAD_TEST_USERS: int = int(os.getenv('LOAD_TEST_USERS', '100'))
    LOAD_TEST_DURATION: str = os.getenv('LOAD_TEST_DURATION', '5m')
    
config = TestConfig()
```

### 2.2 test_data.py - 测试数据
```python
# config/test_data.py
from typing import Dict, List, Any
import json
import random
from faker import Faker

fake = Faker('zh_CN')

class TestData:
    """测试数据生成器"""
    
    # 用户测试数据
    VALID_USERS = {
        'teacher': {
            'username': 'teacher001',
            'password': 'Teacher123!',
            'email': 'teacher@test.com',
            'role': 'teacher'
        },
        'student': {
            'username': 'student001',
            'password': 'Student123!',
            'email': 'student@test.com',
            'role': 'student'
        },
        'admin': {
            'username': 'admin001',
            'password': 'Admin123!',
            'email': 'admin@test.com',
            'role': 'admin'
        }
    }
    
    # 无效用户数据
    INVALID_USERS = [
        {'username': '', 'password': 'password123'},
        {'username': 'testuser', 'password': ''},
        {'username': 'invalid', 'password': 'wrong'},
        {'username': 'test@test.com', 'password': '123'},  # 弱密码
    ]
    
    # 成绩测试数据
    GRADE_DATA = {
        'valid_grade': {
            'student_id': 'STU001',
            'subject': '数学',
            'score': 85,
            'exam_type': '期中考试',
            'exam_date': '2024-01-15'
        },
        'invalid_grades': [
            {'student_id': '', 'subject': '数学', 'score': 85},
            {'student_id': 'STU001', 'subject': '', 'score': 85},
            {'student_id': 'STU001', 'subject': '数学', 'score': -10},
            {'student_id': 'STU001', 'subject': '数学', 'score': 150},
        ]
    }
    
    @staticmethod
    def generate_student_data(count: int = 1) -> List[Dict[str, Any]]:
        """生成学生测试数据"""
        students = []
        for i in range(count):
            student = {
                'id': f'STU{i+1:03d}',
                'name': fake.name(),
                'class_id': f'CLASS{random.randint(1, 10):02d}',
                'grade_level': random.choice(['高一', '高二', '高三']),
                'email': fake.email(),
                'phone': fake.phone_number(),
                'created_at': fake.date_time_this_year().isoformat()
            }
            students.append(student)
        return students
    
    @staticmethod
    def generate_grade_data(student_count: int = 50, subject_count: int = 5) -> List[Dict[str, Any]]:
        """生成成绩测试数据"""
        subjects = ['数学', '语文', '英语', '物理', '化学', '生物', '历史', '地理']
        exam_types = ['期中考试', '期末考试', '月考', '周测']
        grades = []
        
        for i in range(student_count):
            for j in range(subject_count):
                grade = {
                    'id': f'GRADE{len(grades)+1:05d}',
                    'student_id': f'STU{i+1:03d}',
                    'subject': random.choice(subjects),
                    'score': random.randint(60, 100),
                    'exam_type': random.choice(exam_types),
                    'exam_date': fake.date_between(start_date='-1y', end_date='today').isoformat(),
                    'teacher_id': f'TEA{random.randint(1, 10):03d}',
                    'class_id': f'CLASS{random.randint(1, 10):02d}'
                }
                grades.append(grade)
        return grades
```

## 3. 页面对象模型 (POM)

### 3.1 base_page.py - 基础页面类
```python
# pages/base_page.py
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import allure
import time
from typing import Tuple, List, Optional

class BasePage:
    """页面基类，包含通用的页面操作方法"""
    
    def __init__(self, driver: webdriver.Remote):
        self.driver = driver
        self.wait = WebDriverWait(driver, 20)
        self.actions = ActionChains(driver)
    
    @allure.step("等待元素可见")
    def wait_for_element_visible(self, locator: Tuple[str, str], timeout: int = 20) -> bool:
        """等待元素可见"""
        try:
            WebDriverWait(self.driver, timeout).until(
                EC.visibility_of_element_located(locator)
            )
            return True
        except TimeoutException:
            return False
    
    @allure.step("等待元素可点击")
    def wait_for_element_clickable(self, locator: Tuple[str, str], timeout: int = 20) -> bool:
        """等待元素可点击"""
        try:
            WebDriverWait(self.driver, timeout).until(
                EC.element_to_be_clickable(locator)
            )
            return True
        except TimeoutException:
            return False
    
    @allure.step("查找元素")
    def find_element(self, locator: Tuple[str, str]):
        """查找单个元素"""
        return self.driver.find_element(*locator)
    
    @allure.step("查找多个元素")
    def find_elements(self, locator: Tuple[str, str]) -> List:
        """查找多个元素"""
        return self.driver.find_elements(*locator)
    
    @allure.step("点击元素")
    def click_element(self, locator: Tuple[str, str]) -> bool:
        """点击元素"""
        try:
            if self.wait_for_element_clickable(locator):
                element = self.find_element(locator)
                element.click()
                return True
            return False
        except Exception as e:
            allure.attach(str(e), name="点击失败", attachment_type=allure.attachment_type.TEXT)
            return False
    
    @allure.step("输入文本")
    def input_text(self, locator: Tuple[str, str], text: str, clear_first: bool = True) -> bool:
        """输入文本"""
        try:
            if self.wait_for_element_visible(locator):
                element = self.find_element(locator)
                if clear_first:
                    element.clear()
                element.send_keys(text)
                return True
            return False
        except Exception as e:
            allure.attach(str(e), name="输入失败", attachment_type=allure.attachment_type.TEXT)
            return False
    
    @allure.step("获取元素文本")
    def get_element_text(self, locator: Tuple[str, str]) -> Optional[str]:
        """获取元素文本"""
        try:
            if self.wait_for_element_visible(locator):
                element = self.find_element(locator)
                return element.text
            return None
        except Exception as e:
            allure.attach(str(e), name="获取文本失败", attachment_type=allure.attachment_type.TEXT)
            return None
    
    @allure.step("检查元素是否存在")
    def is_element_present(self, locator: Tuple[str, str]) -> bool:
        """检查元素是否存在"""
        try:
            self.find_element(locator)
            return True
        except NoSuchElementException:
            return False
    
    @allure.step("滚动到元素")
    def scroll_to_element(self, locator: Tuple[str, str]) -> bool:
        """滚动到元素"""
        try:
            element = self.find_element(locator)
            self.driver.execute_script("arguments[0].scrollIntoView(true);", element)
            time.sleep(0.5)
            return True
        except Exception as e:
            allure.attach(str(e), name="滚动失败", attachment_type=allure.attachment_type.TEXT)
            return False
    
    @allure.step("截图")
    def take_screenshot(self, name: str = "screenshot") -> str:
        """截图"""
        screenshot_path = f"screenshots/{name}_{int(time.time())}.png"
        self.driver.save_screenshot(screenshot_path)
        allure.attach.file(screenshot_path, name=name, attachment_type=allure.attachment_type.PNG)
        return screenshot_path
    
    @allure.step("等待页面加载完成")
    def wait_for_page_load(self, timeout: int = 30) -> bool:
        """等待页面加载完成"""
        try:
            WebDriverWait(self.driver, timeout).until(
                lambda driver: driver.execute_script("return document.readyState") == "complete"
            )
            return True
        except TimeoutException:
            return False
```

### 3.2 login_page.py - 登录页面
```python
# pages/login_page.py
from selenium.webdriver.common.by import By
import allure
from .base_page import BasePage
from config.settings import config

class LoginPage(BasePage):
    """登录页面对象"""
    
    # 页面元素定位器
    USERNAME_INPUT = (By.ID, "username")
    PASSWORD_INPUT = (By.ID, "password")
    LOGIN_BUTTON = (By.CSS_SELECTOR, "button[type='submit']")
    ERROR_MESSAGE = (By.CSS_SELECTOR, ".error-message")
    REMEMBER_ME_CHECKBOX = (By.ID, "remember-me")
    FORGOT_PASSWORD_LINK = (By.CSS_SELECTOR, "a[href*='forgot-password']")
    REGISTER_LINK = (By.CSS_SELECTOR, "a[href*='register']")
    
    # 页面标题和URL
    PAGE_TITLE = "智能教学助手 - 登录"
    PAGE_URL = f"{config.BASE_URL}/login"
    
    @allure.step("打开登录页面")
    def open(self):
        """打开登录页面"""
        self.driver.get(self.PAGE_URL)
        self.wait_for_page_load()
        return self
    
    @allure.step("输入用户名")
    def enter_username(self, username: str):
        """输入用户名"""
        self.input_text(self.USERNAME_INPUT, username)
        return self
    
    @allure.step("输入密码")
    def enter_password(self, password: str):
        """输入密码"""
        self.input_text(self.PASSWORD_INPUT, password)
        return self
    
    @allure.step("点击登录按钮")
    def click_login_button(self):
        """点击登录按钮"""
        self.click_element(self.LOGIN_BUTTON)
        return self
    
    @allure.step("执行登录操作")
    def login(self, username: str, password: str, remember_me: bool = False):
        """执行完整的登录操作"""
        self.enter_username(username)
        self.enter_password(password)
        
        if remember_me:
            self.click_element(self.REMEMBER_ME_CHECKBOX)
        
        self.click_login_button()
        return self
    
    @allure.step("获取错误信息")
    def get_error_message(self) -> str:
        """获取错误信息"""
        return self.get_element_text(self.ERROR_MESSAGE) or ""
    
    @allure.step("检查是否登录成功")
    def is_login_successful(self) -> bool:
        """检查是否登录成功（通过URL变化判断）"""
        current_url = self.driver.current_url
        return "/dashboard" in current_url or "/home" in current_url
    
    @allure.step("检查登录页面元素")
    def verify_login_page_elements(self) -> dict:
        """验证登录页面所有元素是否存在"""
        elements_status = {
            'username_input': self.is_element_present(self.USERNAME_INPUT),
            'password_input': self.is_element_present(self.PASSWORD_INPUT),
            'login_button': self.is_element_present(self.LOGIN_BUTTON),
            'remember_me': self.is_element_present(self.REMEMBER_ME_CHECKBOX),
            'forgot_password': self.is_element_present(self.FORGOT_PASSWORD_LINK),
            'register_link': self.is_element_present(self.REGISTER_LINK)
        }
        return elements_status
```

### 3.3 grade_management_page.py - 成绩管理页面
```python
# pages/grade_management_page.py
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import Select
import allure
import time
from .base_page import BasePage
from config.settings import config

class GradeManagementPage(BasePage):
    """成绩管理页面对象"""
    
    # 页面元素定位器
    ADD_GRADE_BUTTON = (By.CSS_SELECTOR, "button[data-action='add-grade']")
    IMPORT_EXCEL_BUTTON = (By.CSS_SELECTOR, "button[data-action='import-excel']")
    EXPORT_BUTTON = (By.CSS_SELECTOR, "button[data-action='export']")
    SEARCH_INPUT = (By.CSS_SELECTOR, "input[placeholder*='搜索']")
    SEARCH_BUTTON = (By.CSS_SELECTOR, "button[data-action='search']")
    
    # 筛选器
    CLASS_FILTER = (By.CSS_SELECTOR, "select[name='class']")
    SUBJECT_FILTER = (By.CSS_SELECTOR, "select[name='subject']")
    EXAM_TYPE_FILTER = (By.CSS_SELECTOR, "select[name='exam_type']")
    
    # 表格相关
    GRADE_TABLE = (By.CSS_SELECTOR, "table.grade-table")
    TABLE_ROWS = (By.CSS_SELECTOR, "table.grade-table tbody tr")
    TABLE_HEADERS = (By.CSS_SELECTOR, "table.grade-table thead th")
    
    # 分页
    PAGINATION = (By.CSS_SELECTOR, ".pagination")
    NEXT_PAGE_BUTTON = (By.CSS_SELECTOR, "button[data-action='next-page']")
    PREV_PAGE_BUTTON = (By.CSS_SELECTOR, "button[data-action='prev-page']")
    PAGE_INFO = (By.CSS_SELECTOR, ".page-info")
    
    # 成绩录入表单
    STUDENT_SELECT = (By.CSS_SELECTOR, "select[name='student_id']")
    SUBJECT_SELECT = (By.CSS_SELECTOR, "select[name='subject']")
    SCORE_INPUT = (By.CSS_SELECTOR, "input[name='score']")
    EXAM_TYPE_SELECT = (By.CSS_SELECTOR, "select[name='exam_type']")
    EXAM_DATE_INPUT = (By.CSS_SELECTOR, "input[name='exam_date']")
    SAVE_BUTTON = (By.CSS_SELECTOR, "button[data-action='save']")
    CANCEL_BUTTON = (By.CSS_SELECTOR, "button[data-action='cancel']")
    
    # 消息提示
    SUCCESS_MESSAGE = (By.CSS_SELECTOR, ".alert-success")
    ERROR_MESSAGE = (By.CSS_SELECTOR, ".alert-error")
    
    PAGE_URL = f"{config.BASE_URL}/grade-management"
    
    @allure.step("打开成绩管理页面")
    def open(self):
        """打开成绩管理页面"""
        self.driver.get(self.PAGE_URL)
        self.wait_for_page_load()
        return self
    
    @allure.step("点击添加成绩按钮")
    def click_add_grade_button(self):
        """点击添加成绩按钮"""
        self.click_element(self.ADD_GRADE_BUTTON)
        return self
    
    @allure.step("搜索学生")
    def search_student(self, keyword: str):
        """搜索学生"""
        self.input_text(self.SEARCH_INPUT, keyword)
        self.click_element(self.SEARCH_BUTTON)
        time.sleep(2)  # 等待搜索结果
        return self
    
    @allure.step("筛选班级")
    def filter_by_class(self, class_name: str):
        """按班级筛选"""
        select = Select(self.find_element(self.CLASS_FILTER))
        select.select_by_visible_text(class_name)
        time.sleep(2)
        return self
    
    @allure.step("筛选科目")
    def filter_by_subject(self, subject: str):
        """按科目筛选"""
        select = Select(self.find_element(self.SUBJECT_FILTER))
        select.select_by_visible_text(subject)
        time.sleep(2)
        return self
    
    @allure.step("录入成绩")
    def add_grade(self, student_id: str, subject: str, score: int, exam_type: str, exam_date: str):
        """录入成绩"""
        # 选择学生
        student_select = Select(self.find_element(self.STUDENT_SELECT))
        student_select.select_by_value(student_id)
        
        # 选择科目
        subject_select = Select(self.find_element(self.SUBJECT_SELECT))
        subject_select.select_by_visible_text(subject)
        
        # 输入分数
        self.input_text(self.SCORE_INPUT, str(score))
        
        # 选择考试类型
        exam_type_select = Select(self.find_element(self.EXAM_TYPE_SELECT))
        exam_type_select.select_by_visible_text(exam_type)
        
        # 输入考试日期
        self.input_text(self.EXAM_DATE_INPUT, exam_date)
        
        # 保存
        self.click_element(self.SAVE_BUTTON)
        return self
    
    @allure.step("获取表格行数")
    def get_table_row_count(self) -> int:
        """获取表格行数"""
        rows = self.find_elements(self.TABLE_ROWS)
        return len(rows)
    
    @allure.step("获取表格数据")
    def get_table_data(self) -> list:
        """获取表格数据"""
        rows = self.find_elements(self.TABLE_ROWS)
        table_data = []
        
        for row in rows:
            cells = row.find_elements(By.TAG_NAME, "td")
            row_data = [cell.text for cell in cells]
            table_data.append(row_data)
        
        return table_data
    
    @allure.step("检查成功消息")
    def is_success_message_displayed(self) -> bool:
        """检查是否显示成功消息"""
        return self.is_element_present(self.SUCCESS_MESSAGE)
    
    @allure.step("获取错误消息")
    def get_error_message(self) -> str:
        """获取错误消息"""
        return self.get_element_text(self.ERROR_MESSAGE) or ""
    
    @allure.step("导入Excel文件")
    def import_excel_file(self, file_path: str):
        """导入Excel文件"""
        self.click_element(self.IMPORT_EXCEL_BUTTON)
        # 这里需要处理文件上传对话框
        file_input = self.driver.find_element(By.CSS_SELECTOR, "input[type='file']")
        file_input.send_keys(file_path)
        return self
```

## 4. UI自动化测试用例

### 4.1 test_login.py - 登录功能测试
```python
# tests/ui_tests/test_login.py
import pytest
import allure
from pages.login_page import LoginPage
from pages.dashboard_page import DashboardPage
from config.test_data import TestData
from utils.driver_manager import DriverManager

@allure.epic("用户认证")
@allure.feature("登录功能")
class TestLogin:
    """登录功能测试类"""
    
    def setup_method(self):
        """测试前置条件"""
        self.driver = DriverManager.get_driver()
        self.login_page = LoginPage(self.driver)
        self.dashboard_page = DashboardPage(self.driver)
    
    def teardown_method(self):
        """测试后置条件"""
        DriverManager.quit_driver()
    
    @allure.story("有效用户登录")
    @allure.severity(allure.severity_level.CRITICAL)
    @pytest.mark.parametrize("user_type", ["teacher", "student", "admin"])
    def test_valid_login(self, user_type):
        """测试有效用户登录"""
        user_data = TestData.VALID_USERS[user_type]
        
        with allure.step(f"使用{user_type}账号登录"):
            self.login_page.open()
            self.login_page.login(user_data['username'], user_data['password'])
        
        with allure.step("验证登录成功"):
            assert self.login_page.is_login_successful(), "登录失败"
            assert self.dashboard_page.is_user_logged_in(), "用户未正确登录"
    
    @allure.story("无效用户登录")
    @allure.severity(allure.severity_level.HIGH)
    @pytest.mark.parametrize("invalid_user", TestData.INVALID_USERS)
    def test_invalid_login(self, invalid_user):
        """测试无效用户登录"""
        with allure.step("使用无效凭据登录"):
            self.login_page.open()
            self.login_page.login(invalid_user['username'], invalid_user['password'])
        
        with allure.step("验证登录失败"):
            assert not self.login_page.is_login_successful(), "登录应该失败"
            error_message = self.login_page.get_error_message()
            assert error_message, "应该显示错误消息"
    
    @allure.story("登录页面元素验证")
    @allure.severity(allure.severity_level.NORMAL)
    def test_login_page_elements(self):
        """测试登录页面元素"""
        with allure.step("打开登录页面"):
            self.login_page.open()
        
        with allure.step("验证页面元素存在"):
            elements = self.login_page.verify_login_page_elements()
            
            assert elements['username_input'], "用户名输入框不存在"
            assert elements['password_input'], "密码输入框不存在"
            assert elements['login_button'], "登录按钮不存在"
            assert elements['remember_me'], "记住我复选框不存在"
    
    @allure.story("记住我功能")
    @allure.severity(allure.severity_level.NORMAL)
    def test_remember_me_functionality(self):
        """测试记住我功能"""
        user_data = TestData.VALID_USERS['teacher']
        
        with allure.step("勾选记住我并登录"):
            self.login_page.open()
            self.login_page.login(user_data['username'], user_data['password'], remember_me=True)
        
        with allure.step("验证登录成功"):
            assert self.login_page.is_login_successful(), "登录失败"
        
        # 这里可以添加更多验证，比如检查cookie或localStorage
    
    @allure.story("登录性能测试")
    @allure.severity(allure.severity_level.MINOR)
    def test_login_performance(self):
        """测试登录性能"""
        user_data = TestData.VALID_USERS['teacher']
        
        import time
        start_time = time.time()
        
        with allure.step("执行登录操作"):
            self.login_page.open()
            self.login_page.login(user_data['username'], user_data['password'])
        
        end_time = time.time()
        login_time = end_time - start_time
        
        with allure.step(f"验证登录时间: {login_time:.2f}秒"):
            assert login_time < 5.0, f"登录时间过长: {login_time:.2f}秒"
            allure.attach(f"{login_time:.2f}秒", name="登录耗时", attachment_type=allure.attachment_type.TEXT)
```

### 4.2 test_grade_management.py - 成绩管理测试
```python
# tests/ui_tests/test_grade_management.py
import pytest
import allure
from pages.login_page import LoginPage
from pages.grade_management_page import GradeManagementPage
from config.test_data import TestData
from utils.driver_manager import DriverManager
from utils.test_helpers import TestHelpers

@allure.epic("成绩管理")
@allure.feature("成绩录入与查询")
class TestGradeManagement:
    """成绩管理功能测试类"""
    
    def setup_method(self):
        """测试前置条件"""
        self.driver = DriverManager.get_driver()
        self.login_page = LoginPage(self.driver)
        self.grade_page = GradeManagementPage(self.driver)
        
        # 登录教师账号
        teacher_data = TestData.VALID_USERS['teacher']
        self.login_page.open().login(teacher_data['username'], teacher_data['password'])
    
    def teardown_method(self):
        """测试后置条件"""
        DriverManager.quit_driver()
    
    @allure.story("成绩录入")
    @allure.severity(allure.severity_level.CRITICAL)
    def test_add_single_grade(self):
        """测试单个成绩录入"""
        grade_data = TestData.GRADE_DATA['valid_grade']
        
        with allure.step("打开成绩管理页面"):
            self.grade_page.open()
        
        with allure.step("点击添加成绩"):
            self.grade_page.click_add_grade_button()
        
        with allure.step("录入成绩信息"):
            self.grade_page.add_grade(
                student_id=grade_data['student_id'],
                subject=grade_data['subject'],
                score=grade_data['score'],
                exam_type=grade_data['exam_type'],
                exam_date=grade_data['exam_date']
            )
        
        with allure.step("验证成绩录入成功"):
            assert self.grade_page.is_success_message_displayed(), "成绩录入失败"
    
    @allure.story("无效成绩录入")
    @allure.severity(allure.severity_level.HIGH)
    @pytest.mark.parametrize("invalid_grade", TestData.GRADE_DATA['invalid_grades'])
    def test_invalid_grade_input(self, invalid_grade):
        """测试无效成绩录入"""
        with allure.step("打开成绩管理页面"):
            self.grade_page.open()
        
        with allure.step("点击添加成绩"):
            self.grade_page.click_add_grade_button()
        
        with allure.step("录入无效成绩信息"):
            self.grade_page.add_grade(
                student_id=invalid_grade.get('student_id', ''),
                subject=invalid_grade.get('subject', ''),
                score=invalid_grade.get('score', 0),
                exam_type=invalid_grade.get('exam_type', ''),
                exam_date=invalid_grade.get('exam_date', '')
            )
        
        with allure.step("验证显示错误信息"):
            error_message = self.grade_page.get_error_message()
            assert error_message, "应该显示错误信息"
    
    @allure.story("成绩搜索")
    @allure.severity(allure.severity_level.HIGH)
    def test_search_grades(self):
        """测试成绩搜索功能"""
        search_keyword = "张三"
        
        with allure.step("打开成绩管理页面"):
            self.grade_page.open()
        
        with allure.step(f"搜索学生: {search_keyword}"):
            initial_count = self.grade_page.get_table_row_count()
            self.grade_page.search_student(search_keyword)
            filtered_count = self.grade_page.get_table_row_count()
        
        with allure.step("验证搜索结果"):
            assert filtered_count <= initial_count, "搜索后结果数量应该减少或保持不变"
            
            # 验证搜索结果包含关键词
            table_data = self.grade_page.get_table_data()
            for row in table_data:
                assert any(search_keyword in cell for cell in row), f"搜索结果应包含关键词: {search_keyword}"
    
    @allure.story("成绩筛选")
    @allure.severity(allure.severity_level.NORMAL)
    def test_filter_grades_by_subject(self):
        """测试按科目筛选成绩"""
        subject = "数学"
        
        with allure.step("打开成绩管理页面"):
            self.grade_page.open()
        
        with allure.step(f"按科目筛选: {subject}"):
            self.grade_page.filter_by_subject(subject)
        
        with allure.step("验证筛选结果"):
            table_data = self.grade_page.get_table_data()
            for row in table_data:
                # 假设科目在第3列（索引2）
                assert subject in row[2], f"筛选结果应只包含{subject}科目"
    
    @allure.story("Excel导入")
    @allure.severity(allure.severity_level.HIGH)
    def test_import_excel_grades(self):
        """测试Excel成绩导入"""
        # 生成测试Excel文件
        excel_file_path = TestHelpers.create_test_excel_file()
        
        with allure.step("打开成绩管理页面"):
            self.grade_page.open()
        
        with allure.step("导入Excel文件"):
            initial_count = self.grade_page.get_table_row_count()
            self.grade_page.import_excel_file(excel_file_path)
        
        with allure.step("验证导入成功"):
            assert self.grade_page.is_success_message_displayed(), "Excel导入失败"
            final_count = self.grade_page.get_table_row_count()
            assert final_count > initial_count, "导入后成绩数量应该增加"
        
        # 清理测试文件
        TestHelpers.cleanup_test_file(excel_file_path)
```

## 5. API自动化测试

### 5.1 test_auth_api.py - 认证API测试
```python
# tests/api_tests/test_auth_api.py
import pytest
import requests
import allure
import jwt
from config.settings import config
from config.test_data import TestData
from utils.test_helpers import APITestHelpers

@allure.epic("API测试")
@allure.feature("认证API")
class TestAuthAPI:
    """认证API测试类"""
    
    def setup_method(self):
        """测试前置条件"""
        self.base_url = config.API_BASE_URL
        self.session = requests.Session()
        self.api_helper = APITestHelpers()
    
    @allure.story("用户登录API")
    @allure.severity(allure.severity_level.CRITICAL)
    def test_login_api_success(self):
        """测试登录API成功场景"""
        user_data = TestData.VALID_USERS['teacher']
        login_data = {
            'username': user_data['username'],
            'password': user_data['password']
        }
        
        with allure.step("发送登录请求"):
            response = self.session.post(
                f"{self.base_url}/auth/login",
                json=login_data,
                headers={'Content-Type': 'application/json'}
            )
        
        with allure.step("验证响应状态码"):
            assert response.status_code == 200, f"期望状态码200，实际{response.status_code}"
        
        with allure.step("验证响应数据"):
            response_data = response.json()
            assert 'access_token' in response_data, "响应中应包含access_token"
            assert 'refresh_token' in response_data, "响应中应包含refresh_token"
            assert 'user_info' in response_data, "响应中应包含user_info"
            
            # 验证JWT token
            token = response_data['access_token']
            decoded_token = jwt.decode(token, options={"verify_signature": False})
            assert decoded_token['username'] == user_data['username'], "Token中用户名不匹配"
        
        # 保存token供后续测试使用
        self.api_helper.set_auth_token(token)
    
    @allure.story("用户登录API失败")
    @allure.severity(allure.severity_level.HIGH)
    @pytest.mark.parametrize("invalid_user", TestData.INVALID_USERS)
    def test_login_api_failure(self, invalid_user):
        """测试登录API失败场景"""
        with allure.step("发送无效登录请求"):
            response = self.session.post(
                f"{self.base_url}/auth/login",
                json=invalid_user,
                headers={'Content-Type': 'application/json'}
            )
        
        with allure.step("验证响应状态码"):
            assert response.status_code in [400, 401], f"期望状态码400或401，实际{response.status_code}"
        
        with allure.step("验证错误响应"):
            response_data = response.json()
            assert 'error' in response_data or 'message' in response_data, "响应中应包含错误信息"
    
    @allure.story("Token刷新API")
    @allure.severity(allure.severity_level.HIGH)
    def test_refresh_token_api(self):
        """测试Token刷新API"""
        # 先登录获取refresh_token
        user_data = TestData.VALID_USERS['teacher']
        login_response = self.session.post(
            f"{self.base_url}/auth/login",
            json={'username': user_data['username'], 'password': user_data['password']}
        )
        refresh_token = login_response.json()['refresh_token']
        
        with allure.step("发送Token刷新请求"):
            response = self.session.post(
                f"{self.base_url}/auth/refresh",
                json={'refresh_token': refresh_token},
                headers={'Content-Type': 'application/json'}
            )
        
        with allure.step("验证响应"):
            assert response.status_code == 200, f"期望状态码200，实际{response.status_code}"
            response_data = response.json()
            assert 'access_token' in response_data, "响应中应包含新的access_token"
    
    @allure.story("用户注销API")
    @allure.severity(allure.severity_level.NORMAL)
    def test_logout_api(self):
        """测试用户注销API"""
        # 先登录获取token
        token = self.api_helper.get_valid_token()
        
        with allure.step("发送注销请求"):
            response = self.session.post(
                f"{self.base_url}/auth/logout",
                headers={'Authorization': f'Bearer {token}'}
            )
        
        with allure.step("验证注销成功"):
            assert response.status_code == 200, f"期望状态码200，实际{response.status_code}"
        
        with allure.step("验证token失效"):
            # 使用已注销的token访问受保护资源应该失败
            protected_response = self.session.get(
                f"{self.base_url}/user/profile",
                headers={'Authorization': f'Bearer {token}'}
            )
            assert protected_response.status_code == 401, "注销后token应该失效"
```

### 5.2 test_grade_api.py - 成绩API测试
```python
# tests/api_tests/test_grade_api.py
import pytest
import requests
import allure
from config.settings import config
from config.test_data import TestData
from utils.test_helpers import APITestHelpers

@allure.epic("API测试")
@allure.feature("成绩管理API")
class TestGradeAPI:
    """成绩管理API测试类"""
    
    def setup_method(self):
        """测试前置条件"""
        self.base_url = config.API_BASE_URL
        self.session = requests.Session()
        self.api_helper = APITestHelpers()
        
        # 获取认证token
        self.token = self.api_helper.get_valid_token()
        self.headers = {
            'Authorization': f'Bearer {self.token}',
            'Content-Type': 'application/json'
        }
    
    @allure.story("创建成绩记录")
    @allure.severity(allure.severity_level.CRITICAL)
    def test_create_grade_success(self):
        """测试创建成绩记录成功"""
        grade_data = TestData.GRADE_DATA['valid_grade']
        
        with allure.step("发送创建成绩请求"):
            response = self.session.post(
                f"{self.base_url}/grades",
                json=grade_data,
                headers=self.headers
            )
        
        with allure.step("验证响应"):
            assert response.status_code == 201, f"期望状态码201，实际{response.status_code}"
            response_data = response.json()
            assert 'id' in response_data, "响应中应包含成绩ID"
            assert response_data['student_id'] == grade_data['student_id'], "学生ID不匹配"
            assert response_data['score'] == grade_data['score'], "分数不匹配"
        
        # 保存创建的成绩ID供后续测试使用
        self.created_grade_id = response_data['id']
    
    @allure.story("创建成绩记录失败")
    @allure.severity(allure.severity_level.HIGH)
    @pytest.mark.parametrize("invalid_grade", TestData.GRADE_DATA['invalid_grades'])
    def test_create_grade_failure(self, invalid_grade):
        """测试创建成绩记录失败"""
        with allure.step("发送无效成绩创建请求"):
            response = self.session.post(
                f"{self.base_url}/grades",
                json=invalid_grade,
                headers=self.headers
            )
        
        with allure.step("验证错误响应"):
            assert response.status_code == 400, f"期望状态码400，实际{response.status_code}"
            response_data = response.json()
            assert 'error' in response_data or 'message' in response_data, "响应中应包含错误信息"
    
    @allure.story("查询成绩列表")
    @allure.severity(allure.severity_level.HIGH)
    def test_get_grades_list(self):
        """测试查询成绩列表"""
        with allure.step("发送查询成绩列表请求"):
            response = self.session.get(
                f"{self.base_url}/grades",
                headers=self.headers
            )
        
        with allure.step("验证响应"):
            assert response.status_code == 200, f"期望状态码200，实际{response.status_code}"
            response_data = response.json()
            assert 'data' in response_data, "响应中应包含data字段"
            assert 'total' in response_data, "响应中应包含total字段"
            assert isinstance(response_data['data'], list), "data应该是列表类型"
    
    @allure.story("分页查询成绩")
    @allure.severity(allure.severity_level.NORMAL)
    def test_get_grades_with_pagination(self):
        """测试分页查询成绩"""
        page_size = 10
        page_num = 1
        
        with allure.step(f"发送分页查询请求 (页码:{page_num}, 页大小:{page_size})"):
            response = self.session.get(
                f"{self.base_url}/grades",
                params={'page': page_num, 'page_size': page_size},
                headers=self.headers
            )
        
        with allure.step("验证分页响应"):
            assert response.status_code == 200, f"期望状态码200，实际{response.status_code}"
            response_data = response.json()
            assert len(response_data['data']) <= page_size, f"返回数据量不应超过{page_size}"
            assert 'page' in response_data, "响应中应包含page字段"
            assert 'page_size' in response_data, "响应中应包含page_size字段"
    
    @allure.story("按条件筛选成绩")
    @allure.severity(allure.severity_level.NORMAL)
    def test_filter_grades_by_subject(self):
        """测试按科目筛选成绩"""
        subject = "数学"
        
        with allure.step(f"发送按科目筛选请求: {subject}"):
            response = self.session.get(
                f"{self.base_url}/grades",
                params={'subject': subject},
                headers=self.headers
            )
        
        with allure.step("验证筛选结果"):
            assert response.status_code == 200, f"期望状态码200，实际{response.status_code}"
            response_data = response.json()
            
            # 验证所有返回的成绩都是指定科目
            for grade in response_data['data']:
                assert grade['subject'] == subject, f"筛选结果应只包含{subject}科目"
    
    @allure.story("更新成绩记录")
    @allure.severity(allure.severity_level.HIGH)
    def test_update_grade(self):
        """测试更新成绩记录"""
        # 先创建一个成绩记录
        grade_data = TestData.GRADE_DATA['valid_grade']
        create_response = self.session.post(
            f"{self.base_url}/grades",
            json=grade_data,
            headers=self.headers
        )
        grade_id = create_response.json()['id']
        
        # 更新数据
        update_data = {'score': 95}
        
        with allure.step(f"发送更新成绩请求 (ID: {grade_id})"):
            response = self.session.put(
                f"{self.base_url}/grades/{grade_id}",
                json=update_data,
                headers=self.headers
            )
        
        with allure.step("验证更新成功"):
            assert response.status_code == 200, f"期望状态码200，实际{response.status_code}"
            response_data = response.json()
            assert response_data['score'] == update_data['score'], "分数更新失败"
    
    @allure.story("删除成绩记录")
    @allure.severity(allure.severity_level.HIGH)
    def test_delete_grade(self):
        """测试删除成绩记录"""
        # 先创建一个成绩记录
        grade_data = TestData.GRADE_DATA['valid_grade']
        create_response = self.session.post(
            f"{self.base_url}/grades",
            json=grade_data,
            headers=self.headers
        )
        grade_id = create_response.json()['id']
        
        with allure.step(f"发送删除成绩请求 (ID: {grade_id})"):
            response = self.session.delete(
                f"{self.base_url}/grades/{grade_id}",
                headers=self.headers
            )
        
        with allure.step("验证删除成功"):
            assert response.status_code == 204, f"期望状态码204，实际{response.status_code}"
        
        with allure.step("验证记录已删除"):
            get_response = self.session.get(
                f"{self.base_url}/grades/{grade_id}",
                headers=self.headers
            )
            assert get_response.status_code == 404, "删除后应该无法找到记录"
```

## 6. 性能测试脚本

### 6.1 load_test.py - 负载测试
```python
# tests/performance_tests/load_test.py
from locust import HttpUser, task, between
import random
import json
from config.test_data import TestData
from config.settings import config

class WebsiteUser(HttpUser):
    """网站用户行为模拟"""
    
    wait_time = between(1, 3)  # 用户操作间隔时间
    host = config.BASE_URL
    
    def on_start(self):
        """用户开始时执行的操作"""
        self.login()
    
    def login(self):
        """用户登录"""
        user_data = random.choice(list(TestData.VALID_USERS.values()))
        response = self.client.post("/api/auth/login", json={
            "username": user_data['username'],
            "password": user_data['password']
        })
        
        if response.status_code == 200:
            self.token = response.json().get('access_token')
            self.client.headers.update({'Authorization': f'Bearer {self.token}'})
    
    @task(3)
    def view_dashboard(self):
        """查看仪表板 - 高频操作"""
        self.client.get("/dashboard")
    
    @task(2)
    def view_grade_list(self):
        """查看成绩列表 - 中频操作"""
        self.client.get("/api/grades", params={
            'page': random.randint(1, 5),
            'page_size': 20
        })
    
    @task(1)
    def search_grades(self):
        """搜索成绩 - 低频操作"""
        search_terms = ['张三', '李四', '王五', '数学', '语文']
        search_term = random.choice(search_terms)
        self.client.get("/api/grades/search", params={
            'keyword': search_term
        })
    
    @task(1)
    def add_grade(self):
        """添加成绩 - 低频操作"""
        grade_data = {
            'student_id': f'STU{random.randint(1, 100):03d}',
            'subject': random.choice(['数学', '语文', '英语', '物理', '化学']),
            'score': random.randint(60, 100),
            'exam_type': random.choice(['期中考试', '期末考试', '月考']),
            'exam_date': '2024-01-15'
        }
        
        self.client.post("/api/grades", json=grade_data)
    
    @task(1)
    def generate_analysis_report(self):
        """生成分析报告 - 低频但资源密集操作"""
        self.client.post("/api/analysis/generate", json={
            'class_id': f'CLASS{random.randint(1, 10):02d}',
            'subject': random.choice(['数学', '语文', '英语']),
            'report_type': 'class_summary'
        })

class APIUser(HttpUser):
    """API用户行为模拟"""
    
    wait_time = between(0.5, 2)
    host = config.API_BASE_URL
    
    def on_start(self):
        """API用户开始时执行的操作"""
        self.login_api()
    
    def login_api(self):
        """API登录"""
        user_data = random.choice(list(TestData.VALID_USERS.values()))
        response = self.client.post("/auth/login", json={
            "username": user_data['username'],
            "password": user_data['password']
        })
        
        if response.status_code == 200:
            self.token = response.json().get('access_token')
            self.client.headers.update({'Authorization': f'Bearer {self.token}'})
    
    @task(5)
    def get_grades_api(self):
        """获取成绩列表API"""
        self.client.get("/grades", params={
            'page': random.randint(1, 10),
            'page_size': random.choice([10, 20, 50])
        })
    
    @task(3)
    def search_grades_api(self):
        """搜索成绩API"""
        self.client.get("/grades/search", params={
            'keyword': random.choice(['张三', '数学', '高一'])
        })
    
    @task(2)
    def create_grade_api(self):
        """创建成绩API"""
        grade_data = TestData.generate_grade_data(1, 1)[0]
        self.client.post("/grades", json=grade_data)
    
    @task(1)
    def get_analytics_api(self):
        """获取分析数据API"""
        self.client.get("/analytics/class-summary", params={
            'class_id': f'CLASS{random.randint(1, 10):02d}'
        })

## 7. 工具配置文件

### 7.1 requirements.txt - Python依赖
```
# 自动化测试依赖
selenium==4.15.0
webdriver-manager==4.0.1
pytest==7.4.3
pytest-html==4.1.1
pytest-xdist==3.3.1
allure-pytest==2.13.2
requests==2.31.0
locust==2.17.0
appium-python-client==3.1.0
faker==19.12.0
pytest-mock==3.12.0
pytest-cov==4.1.0

# 数据处理
pandas==2.1.3
openpyxl==3.1.2

# 图像处理（用于UI对比测试）
Pillow==10.1.0
opencv-python==4.8.1.78

# 数据库连接
PyMySQL==1.1.0
psycopg2-binary==2.9.9

# JWT处理
PyJWT==2.8.0

# 配置管理
python-dotenv==1.0.0
```

### 7.2 pytest.ini - pytest配置
```ini
[tool:pytest]
# 测试目录
testpaths = tests

# 测试文件模式
python_files = test_*.py *_test.py

# 测试类模式
python_classes = Test*

# 测试函数模式
python_functions = test_*

# 添加标记
markers =
    smoke: 冒烟测试
    regression: 回归测试
    ui: UI测试
    api: API测试
    performance: 性能测试
    security: 安全测试
    slow: 慢速测试
    critical: 关键功能测试

# 输出配置
addopts = 
    -v
    --tb=short
    --strict-markers
    --disable-warnings
    --html=reports/report.html
    --self-contained-html
    --alluredir=reports/allure-results
    --cov=src
    --cov-report=html:reports/coverage
    --cov-report=term-missing

# 最小版本要求
minversion = 6.0

# 测试发现
collect_ignore = ["setup.py"]
```

### 7.3 conftest.py - pytest配置和fixture
```python
# conftest.py
import pytest
import os
import shutil
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from webdriver_manager.chrome import ChromeDriverManager
from webdriver_manager.firefox import GeckoDriverManager
from config.settings import config
from utils.driver_manager import DriverManager
from utils.test_helpers import TestHelpers

# 测试会话级别的fixture
@pytest.fixture(scope="session", autouse=True)
def setup_test_environment():
    """设置测试环境"""
    # 创建必要的目录
    os.makedirs(config.SCREENSHOT_PATH, exist_ok=True)
    os.makedirs(config.REPORT_PATH, exist_ok=True)
    os.makedirs("test_data", exist_ok=True)
    
    yield
    
    # 清理测试环境
    TestHelpers.cleanup_test_data()

@pytest.fixture(scope="function")
def driver():
    """WebDriver fixture"""
    driver = DriverManager.get_driver()
    yield driver
    DriverManager.quit_driver()

@pytest.fixture(scope="function")
def api_client():
    """API客户端fixture"""
    from utils.test_helpers import APITestHelpers
    client = APITestHelpers()
    yield client
    client.cleanup()

@pytest.fixture(scope="function")
def test_data():
    """测试数据fixture"""
    from config.test_data import TestData
    return TestData()

# 钩子函数
def pytest_configure(config):
    """pytest配置钩子"""
    # 设置测试报告标题
    config._metadata = {
        "项目名称": "智能教学助手",
        "测试环境": config.getoption("--env", default="test"),
        "浏览器": config.getoption("--browser", default="chrome"),
        "测试时间": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }

def pytest_runtest_makereport(item, call):
    """测试报告钩子"""
    if call.when == "call":
        # 测试失败时截图
        if call.excinfo is not None and hasattr(item, "funcargs"):
            driver = item.funcargs.get("driver")
            if driver:
                screenshot_path = f"{config.SCREENSHOT_PATH}/failure_{item.name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                driver.save_screenshot(screenshot_path)
                
                # 添加到Allure报告
                import allure
                allure.attach.file(
                    screenshot_path,
                    name="失败截图",
                    attachment_type=allure.attachment_type.PNG
                )

# 命令行参数
def pytest_addoption(parser):
    """添加命令行参数"""
    parser.addoption(
        "--browser",
        action="store",
        default="chrome",
        help="指定浏览器: chrome, firefox, safari"
    )
    parser.addoption(
        "--headless",
        action="store_true",
        help="无头模式运行"
    )
    parser.addoption(
        "--env",
        action="store",
        default="test",
        help="测试环境: dev, test, staging, prod"
    )
    parser.addoption(
        "--parallel",
        action="store",
        default="1",
        help="并行执行的进程数"
    )
```

## 8. 工具类实现

### 8.1 driver_manager.py - WebDriver管理
```python
# utils/driver_manager.py
from selenium import webdriver
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.webdriver.safari.options import Options as SafariOptions
from webdriver_manager.chrome import ChromeDriverManager
from webdriver_manager.firefox import GeckoDriverManager
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.firefox.service import Service as FirefoxService
from config.settings import config
import threading

class DriverManager:
    """WebDriver管理器"""
    
    _drivers = threading.local()
    
    @classmethod
    def get_driver(cls, browser=None, headless=None):
        """获取WebDriver实例"""
        browser = browser or config.BROWSER
        headless = headless if headless is not None else config.HEADLESS
        
        if hasattr(cls._drivers, 'driver') and cls._drivers.driver:
            return cls._drivers.driver
        
        if browser.lower() == 'chrome':
            cls._drivers.driver = cls._create_chrome_driver(headless)
        elif browser.lower() == 'firefox':
            cls._drivers.driver = cls._create_firefox_driver(headless)
        elif browser.lower() == 'safari':
            cls._drivers.driver = cls._create_safari_driver()
        else:
            raise ValueError(f"不支持的浏览器: {browser}")
        
        # 设置隐式等待
        cls._drivers.driver.implicitly_wait(config.IMPLICIT_WAIT)
        
        return cls._drivers.driver
    
    @classmethod
    def _create_chrome_driver(cls, headless=False):
        """创建Chrome WebDriver"""
        options = ChromeOptions()
        
        if headless:
            options.add_argument('--headless')
        
        # Chrome性能优化选项
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--disable-gpu')
        options.add_argument('--disable-extensions')
        options.add_argument('--disable-plugins')
        options.add_argument('--disable-images')
        options.add_argument('--disable-javascript')
        options.add_argument('--window-size=1920,1080')
        
        # 禁用通知
        prefs = {
            "profile.default_content_setting_values.notifications": 2,
            "profile.default_content_settings.popups": 0
        }
        options.add_experimental_option("prefs", prefs)
        
        service = ChromeService(ChromeDriverManager().install())
        return webdriver.Chrome(service=service, options=options)
    
    @classmethod
    def _create_firefox_driver(cls, headless=False):
        """创建Firefox WebDriver"""
        options = FirefoxOptions()
        
        if headless:
            options.add_argument('--headless')
        
        # Firefox性能优化选项
        options.add_argument('--width=1920')
        options.add_argument('--height=1080')
        
        service = FirefoxService(GeckoDriverManager().install())
        return webdriver.Firefox(service=service, options=options)
    
    @classmethod
    def _create_safari_driver(cls):
        """创建Safari WebDriver"""
        return webdriver.Safari()
    
    @classmethod
    def quit_driver(cls):
        """退出WebDriver"""
        if hasattr(cls._drivers, 'driver') and cls._drivers.driver:
            cls._drivers.driver.quit()
            cls._drivers.driver = None
```

### 8.2 test_helpers.py - 测试辅助工具
```python
# utils/test_helpers.py
import os
import json
import pandas as pd
import requests
import time
from typing import Dict, List, Any, Optional
from config.settings import config
from config.test_data import TestData

class TestHelpers:
    """测试辅助工具类"""
    
    @staticmethod
    def create_test_excel_file(file_name: str = "test_grades.xlsx") -> str:
        """创建测试用Excel文件"""
        # 生成测试数据
        grades_data = TestData.generate_grade_data(50, 3)
        
        # 转换为DataFrame
        df = pd.DataFrame(grades_data)
        
        # 保存为Excel文件
        file_path = f"test_data/{file_name}"
        df.to_excel(file_path, index=False)
        
        return os.path.abspath(file_path)
    
    @staticmethod
    def cleanup_test_file(file_path: str):
        """清理测试文件"""
        if os.path.exists(file_path):
            os.remove(file_path)
    
    @staticmethod
    def cleanup_test_data():
        """清理所有测试数据"""
        test_data_dir = "test_data"
        if os.path.exists(test_data_dir):
            import shutil
            shutil.rmtree(test_data_dir)
    
    @staticmethod
    def wait_for_condition(condition_func, timeout: int = 30, interval: float = 1.0) -> bool:
        """等待条件满足"""
        start_time = time.time()
        while time.time() - start_time < timeout:
            if condition_func():
                return True
            time.sleep(interval)
        return False
    
    @staticmethod
    def compare_images(image1_path: str, image2_path: str, threshold: float = 0.95) -> bool:
        """比较两张图片的相似度"""
        try:
            from PIL import Image
            import numpy as np
            
            # 打开图片
            img1 = Image.open(image1_path)
            img2 = Image.open(image2_path)
            
            # 调整大小为相同尺寸
            img1 = img1.resize((800, 600))
            img2 = img2.resize((800, 600))
            
            # 转换为numpy数组
            arr1 = np.array(img1)
            arr2 = np.array(img2)
            
            # 计算相似度
            similarity = np.corrcoef(arr1.flatten(), arr2.flatten())[0, 1]
            
            return similarity >= threshold
        except Exception as e:
            print(f"图片比较失败: {e}")
            return False
    
    @staticmethod
    def generate_test_report_data() -> Dict[str, Any]:
        """生成测试报告数据"""
        return {
            "test_summary": {
                "total_tests": 150,
                "passed": 142,
                "failed": 6,
                "skipped": 2,
                "pass_rate": 94.67
            },
            "test_categories": {
                "功能测试": {"total": 80, "passed": 76, "failed": 4},
                "UI测试": {"total": 35, "passed": 33, "failed": 2},
                "API测试": {"total": 25, "passed": 25, "failed": 0},
                "性能测试": {"total": 10, "passed": 8, "failed": 0}
            },
            "execution_time": "45分钟",
            "environment": "测试环境",
            "browser": "Chrome 119.0"
        }

class APITestHelpers:
    """API测试辅助工具类"""
    
    def __init__(self):
        self.base_url = config.API_BASE_URL
        self.session = requests.Session()
        self.auth_token = None
    
    def get_valid_token(self) -> str:
        """获取有效的认证token"""
        if self.auth_token:
            return self.auth_token
        
        # 使用测试用户登录获取token
        user_data = TestData.VALID_USERS['teacher']
        response = self.session.post(
            f"{self.base_url}/auth/login",
            json={
                'username': user_data['username'],
                'password': user_data['password']
            }
        )
        
        if response.status_code == 200:
            self.auth_token = response.json()['access_token']
            return self.auth_token
        
        raise Exception("无法获取认证token")
    
    def set_auth_token(self, token: str):
        """设置认证token"""
        self.auth_token = token
        self.session.headers.update({'Authorization': f'Bearer {token}'})
    
    def make_authenticated_request(self, method: str, endpoint: str, **kwargs) -> requests.Response:
        """发送认证请求"""
        if not self.auth_token:
            self.get_valid_token()
        
        headers = kwargs.get('headers', {})
        headers['Authorization'] = f'Bearer {self.auth_token}'
        kwargs['headers'] = headers
        
        return self.session.request(method, f"{self.base_url}{endpoint}", **kwargs)
    
    def cleanup(self):
        """清理资源"""
        if self.session:
            self.session.close()
```

## 9. 执行指南

### 9.1 环境准备

#### 安装依赖
```bash
# 创建虚拟环境
python -m venv venv
source venv/bin/activate  # Linux/Mac
# 或
venv\Scripts\activate  # Windows

# 安装依赖
pip install -r requirements.txt

# 安装Allure（用于生成测试报告）
# Mac
brew install allure

# Windows
scoop install allure

# Linux
sudo apt-get install allure
```

#### 环境变量配置
```bash
# 创建.env文件
cat > .env << EOF
TEST_BASE_URL=http://localhost:3000
API_BASE_URL=http://localhost:8000/api
BROWSER=chrome
HEADLESS=false
DB_HOST=localhost
DB_PORT=3306
DB_NAME=test_ailearn
DB_USER=test_user
DB_PASSWORD=test_password
EOF
```

### 9.2 测试执行命令

#### 基础执行命令
```bash
# 执行所有测试
pytest

# 执行特定模块测试
pytest tests/ui_tests/
pytest tests/api_tests/
pytest tests/performance_tests/

# 执行特定测试文件
pytest tests/ui_tests/test_login.py
pytest tests/api_tests/test_auth_api.py

# 执行特定测试用例
pytest tests/ui_tests/test_login.py::TestLogin::test_valid_login
```

#### 标记执行
```bash
# 执行冒烟测试
pytest -m smoke

# 执行回归测试
pytest -m regression

# 执行关键功能测试
pytest -m critical

# 排除慢速测试
pytest -m "not slow"

# 组合标记
pytest -m "smoke and not slow"
```

#### 并行执行
```bash
# 并行执行（4个进程）
pytest -n 4

# 自动检测CPU核心数并行执行
pytest -n auto

# 分布式执行（指定进程数）
pytest -n 8 --dist=loadscope
```

#### 浏览器和环境配置
```bash
# 指定浏览器
pytest --browser=chrome
pytest --browser=firefox
pytest --browser=safari

# 无头模式
pytest --headless

# 指定测试环境
pytest --env=dev
pytest --env=test
pytest --env=staging
```

### 9.3 性能测试执行

#### Locust性能测试
```bash
# 启动Locust Web界面
locust -f tests/performance_tests/load_test.py --host=http://localhost:3000

# 命令行模式执行
locust -f tests/performance_tests/load_test.py --host=http://localhost:3000 \
       --users 100 --spawn-rate 10 --run-time 5m --headless

# 生成性能测试报告
locust -f tests/performance_tests/load_test.py --host=http://localhost:3000 \
       --users 100 --spawn-rate 10 --run-time 5m --headless \
       --html reports/performance_report.html
```

### 9.4 测试报告生成

#### HTML报告
```bash
# 生成pytest-html报告
pytest --html=reports/report.html --self-contained-html
```

#### Allure报告
```bash
# 生成Allure测试结果
pytest --alluredir=reports/allure-results

# 启动Allure服务查看报告
allure serve reports/allure-results

# 生成静态Allure报告
allure generate reports/allure-results -o reports/allure-report --clean
```

#### 覆盖率报告
```bash
# 生成覆盖率报告
pytest --cov=src --cov-report=html:reports/coverage

# 查看覆盖率报告
open reports/coverage/index.html
```

### 9.5 CI/CD集成示例

#### GitHub Actions配置
```yaml
# .github/workflows/test.yml
name: 自动化测试

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        python-version: [3.8, 3.9, 3.10]
        browser: [chrome, firefox]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: 设置Python环境
      uses: actions/setup-python@v3
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: 安装依赖
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: 运行测试
      run: |
        pytest --browser=${{ matrix.browser }} --headless \
               --alluredir=allure-results \
               --html=reports/report.html --self-contained-html
      env:
        TEST_BASE_URL: ${{ secrets.TEST_BASE_URL }}
        API_BASE_URL: ${{ secrets.API_BASE_URL }}
    
    - name: 上传测试报告
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-reports-${{ matrix.python-version }}-${{ matrix.browser }}
        path: |
          reports/
          allure-results/
```

### 9.6 最佳实践建议

#### 测试执行策略
1. **分层执行**：先执行冒烟测试，再执行完整回归测试
2. **并行优化**：合理设置并行进程数，避免资源竞争
3. **失败重试**：对不稳定的测试用例设置重试机制
4. **数据隔离**：确保测试数据独立，避免相互影响

#### 报告和监控
1. **实时监控**：集成测试结果到监控系统
2. **趋势分析**：跟踪测试通过率和执行时间趋势
3. **失败分析**：自动分类和分析测试失败原因
4. **通知机制**：测试失败时及时通知相关人员

#### 维护和优化
1. **定期更新**：及时更新测试用例和测试数据
2. **性能优化**：优化测试执行速度和资源使用
3. **代码质量**：保持测试代码的可读性和可维护性
4. **文档更新**：及时更新测试文档和执行指南

## 10. 总结

本自动化测试脚本示例提供了智能教学助手应用的完整测试解决方案，包括：

### 10.1 覆盖范围
- **UI自动化测试**：登录、成绩管理、仪表板等核心功能
- **API自动化测试**：认证、成绩CRUD、数据分析等接口
- **性能测试**：负载测试和压力测试
- **工具支持**：WebDriver管理、测试数据生成、报告生成

### 10.2 技术特点
- **模块化设计**：页面对象模型，便于维护
- **数据驱动**：参数化测试，提高覆盖率
- **并行执行**：支持多进程并行，提高效率
- **丰富报告**：HTML、Allure、覆盖率多种报告

### 10.3 质量保障
- **分层测试**：单元、集成、端到端全覆盖
- **持续集成**：CI/CD流水线自动执行
- **监控告警**：实时监控测试结果
- **数据管理**：测试数据生成和清理

通过这套自动化测试方案，可以有效保障智能教学助手应用的质量，提高测试效率，降低人工测试成本。