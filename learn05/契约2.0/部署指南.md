# 智能教学助手2.0 部署指南

## 目录
- [系统架构概述](#系统架构概述)
- [环境要求](#环境要求)
- [基础环境搭建](#基础环境搭建)
- [数据库部署](#数据库部署)
- [后端服务部署](#后端服务部署)
- [前端应用部署](#前端应用部署)
- [AI服务配置](#ai服务配置)
- [监控与日志](#监控与日志)
- [安全配置](#安全配置)
- [性能优化](#性能优化)
- [故障排除](#故障排除)

## 系统架构概述

智能教学助手2.0采用微服务架构，主要组件包括：

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端应用      │    │   API网关       │    │   负载均衡器    │
│   (React/Vue)   │◄──►│   (Nginx)       │◄──►│   (Nginx)       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户服务      │    │   教学服务      │    │   AI服务        │
│   (FastAPI)     │    │   (FastAPI)     │    │   (FastAPI)     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   MySQL数据库   │    │   Redis缓存     │    │   文件存储      │
│   (主从复制)    │    │   (集群)        │    │   (OSS/S3)      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## 环境要求

### 硬件要求

**生产环境推荐配置：**
- CPU: 8核心以上
- 内存: 16GB以上
- 存储: SSD 500GB以上
- 网络: 100Mbps以上

**开发环境最低配置：**
- CPU: 4核心
- 内存: 8GB
- 存储: SSD 200GB
- 网络: 10Mbps以上

### 软件要求

| 组件 | 版本要求 | 说明 |
|------|----------|------|
| Python | 3.9+ | 后端开发语言 |
| Node.js | 16+ | 前端构建工具 |
| MySQL | 8.0+ | 主数据库 |
| Redis | 6.0+ | 缓存和会话存储 |
| Nginx | 1.20+ | 反向代理和静态文件服务 |
| Docker | 20.0+ | 容器化部署 |
| Docker Compose | 2.0+ | 容器编排 |

## 基础环境搭建

### 1. 服务器准备

```bash
# 更新系统包
sudo apt update && sudo apt upgrade -y

# 安装基础工具
sudo apt install -y curl wget git vim htop tree

# 安装Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker $USER

# 安装Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

# 验证安装
docker --version
docker-compose --version
```

### 2. 目录结构创建

```bash
# 创建项目目录
sudo mkdir -p /opt/intelligent-teaching-assistant
cd /opt/intelligent-teaching-assistant

# 创建子目录
mkdir -p {\
  backend/{app,config,logs,data},\
  frontend/{dist,config},\
  database/{data,backup,scripts},\
  nginx/{conf,logs,ssl},\
  redis/{data,config},\
  monitoring/{prometheus,grafana},\
  scripts/{deploy,backup,maintenance}\
}

# 设置权限
sudo chown -R $USER:$USER /opt/intelligent-teaching-assistant
```

## 数据库部署

### 1. MySQL主从配置

**主库配置 (docker-compose.mysql-master.yml):**

```yaml
version: '3.8'
services:
  mysql-master:
    image: mysql:8.0
    container_name: mysql-master
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: intelligent_teaching_assistant
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    ports:
      - "3306:3306"
    volumes:
      - ./database/data/master:/var/lib/mysql
      - ./database/scripts:/docker-entrypoint-initdb.d
      - ./database/config/master.cnf:/etc/mysql/conf.d/master.cnf
    command: --server-id=1 --log-bin=mysql-bin --binlog-do-db=intelligent_teaching_assistant
    networks:
      - app-network

networks:
  app-network:
    driver: bridge
```

**从库配置 (docker-compose.mysql-slave.yml):**

```yaml
version: '3.8'
services:
  mysql-slave:
    image: mysql:8.0
    container_name: mysql-slave
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: intelligent_teaching_assistant
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    ports:
      - "3307:3306"
    volumes:
      - ./database/data/slave:/var/lib/mysql
      - ./database/config/slave.cnf:/etc/mysql/conf.d/slave.cnf
    command: --server-id=2 --relay-log=mysql-relay-bin --read-only=1
    networks:
      - app-network
    depends_on:
      - mysql-master

networks:
  app-network:
    external: true
```

**MySQL配置文件:**

```ini
# database/config/master.cnf
[mysqld]
server-id = 1
log-bin = mysql-bin
binlog-do-db = intelligent_teaching_assistant
binlog-format = ROW
max_binlog_size = 100M
expire_logs_days = 7

# 性能优化
innodb_buffer_pool_size = 2G
innodb_log_file_size = 256M
innodb_flush_log_at_trx_commit = 2
innodb_flush_method = O_DIRECT

# 连接配置
max_connections = 1000
max_connect_errors = 10000
wait_timeout = 28800
interactive_timeout = 28800

# 字符集配置
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci
```

### 2. 数据库初始化

```bash
# 启动MySQL主库
docker-compose -f docker-compose.mysql-master.yml up -d

# 等待数据库启动
sleep 30

# 执行数据库初始化脚本
docker exec -i mysql-master mysql -uroot -p${MYSQL_ROOT_PASSWORD} < database/scripts/数据库设计文档.sql

# 创建复制用户
docker exec -i mysql-master mysql -uroot -p${MYSQL_ROOT_PASSWORD} -e "
CREATE USER 'replication'@'%' IDENTIFIED BY '${REPLICATION_PASSWORD}';
GRANT REPLICATION SLAVE ON *.* TO 'replication'@'%';
FLUSH PRIVILEGES;
"

# 获取主库状态
docker exec mysql-master mysql -uroot -p${MYSQL_ROOT_PASSWORD} -e "SHOW MASTER STATUS;"
```

### 3. Redis集群配置

**Redis配置 (docker-compose.redis.yml):**

```yaml
version: '3.8'
services:
  redis-master:
    image: redis:6.2-alpine
    container_name: redis-master
    restart: always
    ports:
      - "6379:6379"
    volumes:
      - ./redis/data/master:/data
      - ./redis/config/redis.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      - app-network

  redis-slave:
    image: redis:6.2-alpine
    container_name: redis-slave
    restart: always
    ports:
      - "6380:6379"
    volumes:
      - ./redis/data/slave:/data
      - ./redis/config/redis-slave.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    depends_on:
      - redis-master
    networks:
      - app-network

networks:
  app-network:
    external: true
```

**Redis配置文件:**

```conf
# redis/config/redis.conf
bind 0.0.0.0
port 6379
protected-mode yes
requirepass ${REDIS_PASSWORD}

# 持久化配置
save 900 1
save 300 10
save 60 10000
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir /data

# AOF配置
appendonly yes
appendfilename "appendonly.aof"
appendfsync everysec

# 内存配置
maxmemory 2gb
maxmemory-policy allkeys-lru

# 日志配置
loglevel notice
logfile "/data/redis.log"
```

## 后端服务部署

### 1. 后端应用配置

**应用配置文件 (backend/config/settings.py):**

```python
import os
from typing import List, Optional
from pydantic import BaseSettings, validator

class Settings(BaseSettings):
    # 应用配置
    APP_NAME: str = "智能教学助手2.0"
    APP_VERSION: str = "2.0.0"
    DEBUG: bool = False
    SECRET_KEY: str
    
    # 服务器配置
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    WORKERS: int = 4
    
    # 数据库配置
    DATABASE_URL: str
    DATABASE_URL_READ: Optional[str] = None
    DB_POOL_SIZE: int = 20
    DB_MAX_OVERFLOW: int = 30
    
    # Redis配置
    REDIS_URL: str
    REDIS_PASSWORD: Optional[str] = None
    
    # AI服务配置
    OPENAI_API_KEY: str
    CLAUDE_API_KEY: Optional[str] = None
    WENXIN_API_KEY: Optional[str] = None
    
    # 文件存储配置
    UPLOAD_PATH: str = "/app/uploads"
    MAX_FILE_SIZE: int = 100 * 1024 * 1024  # 100MB
    ALLOWED_EXTENSIONS: List[str] = ["jpg", "jpeg", "png", "pdf", "doc", "docx"]
    
    # 安全配置
    JWT_SECRET_KEY: str
    JWT_ALGORITHM: str = "HS256"
    JWT_EXPIRE_MINUTES: int = 1440  # 24小时
    
    # CORS配置
    CORS_ORIGINS: List[str] = ["*"]
    
    # 日志配置
    LOG_LEVEL: str = "INFO"
    LOG_FILE: str = "/app/logs/app.log"
    
    @validator('DATABASE_URL_READ')
    def set_read_db_url(cls, v, values):
        if not v:
            return values.get('DATABASE_URL')
        return v
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
```

**Docker配置 (backend/Dockerfile):**

```dockerfile
FROM python:3.9-slim

# 设置工作目录
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    libffi-dev \
    libssl-dev \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建必要目录
RUN mkdir -p /app/logs /app/uploads

# 设置权限
RUN chmod +x /app/scripts/start.sh

# 暴露端口
EXPOSE 8000

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# 启动命令
CMD ["/app/scripts/start.sh"]
```

**启动脚本 (backend/scripts/start.sh):**

```bash
#!/bin/bash
set -e

# 等待数据库启动
echo "等待数据库连接..."
while ! python -c "import pymysql; pymysql.connect(host='mysql-master', user='${MYSQL_USER}', password='${MYSQL_PASSWORD}', database='intelligent_teaching_assistant')" 2>/dev/null; do
    sleep 1
done
echo "数据库连接成功"

# 运行数据库迁移
echo "执行数据库迁移..."
python scripts/migrate.py

# 启动应用
echo "启动应用服务..."
if [ "$DEBUG" = "true" ]; then
    uvicorn main:app --host 0.0.0.0 --port 8000 --reload
else
    gunicorn main:app -w $WORKERS -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000
fi
```

### 2. 后端服务编排

**后端服务配置 (docker-compose.backend.yml):**

```yaml
version: '3.8'
services:
  backend-api:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: backend-api
    restart: always
    environment:
      - DEBUG=false
      - DATABASE_URL=mysql+pymysql://${MYSQL_USER}:${MYSQL_PASSWORD}@mysql-master:3306/intelligent_teaching_assistant
      - DATABASE_URL_READ=mysql+pymysql://${MYSQL_USER}:${MYSQL_PASSWORD}@mysql-slave:3306/intelligent_teaching_assistant
      - REDIS_URL=redis://redis-master:6379/0
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - SECRET_KEY=${SECRET_KEY}
      - JWT_SECRET_KEY=${JWT_SECRET_KEY}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - CLAUDE_API_KEY=${CLAUDE_API_KEY}
    ports:
      - "8000:8000"
    volumes:
      - ./backend/logs:/app/logs
      - ./backend/uploads:/app/uploads
    depends_on:
      - mysql-master
      - redis-master
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  backend-worker:
    build:
      context: ./backend
      dockerfile: Dockerfile.worker
    container_name: backend-worker
    restart: always
    environment:
      - DATABASE_URL=mysql+pymysql://${MYSQL_USER}:${MYSQL_PASSWORD}@mysql-master:3306/intelligent_teaching_assistant
      - REDIS_URL=redis://redis-master:6379/0
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - CLAUDE_API_KEY=${CLAUDE_API_KEY}
    volumes:
      - ./backend/logs:/app/logs
      - ./backend/uploads:/app/uploads
    depends_on:
      - mysql-master
      - redis-master
    networks:
      - app-network
    command: celery -A app.worker worker --loglevel=info

networks:
  app-network:
    external: true
```

## 前端应用部署

### 1. 前端构建配置

**构建脚本 (frontend/scripts/build.sh):**

```bash
#!/bin/bash
set -e

echo "开始构建前端应用..."

# 安装依赖
npm ci

# 构建生产版本
npm run build

# 复制静态文件
cp -r dist/* /opt/intelligent-teaching-assistant/frontend/dist/

echo "前端构建完成"
```

**Nginx配置 (nginx/conf/nginx.conf):**

```nginx
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
    multi_accept on;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    # 日志格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    
    # 基础配置
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 100M;
    
    # Gzip压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;
    
    # 后端服务负载均衡
    upstream backend {
        least_conn;
        server backend-api:8000 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }
    
    # 主站点配置
    server {
        listen 80;
        server_name _;
        
        # 重定向到HTTPS
        return 301 https://$server_name$request_uri;
    }
    
    server {
        listen 443 ssl http2;
        server_name _;
        
        # SSL配置
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
        
        # 安全头
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        add_header X-XSS-Protection "1; mode=block";
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
        
        # 前端静态文件
        location / {
            root /usr/share/nginx/html;
            index index.html;
            try_files $uri $uri/ /index.html;
            
            # 缓存配置
            location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
                expires 1y;
                add_header Cache-Control "public, immutable";
            }
        }
        
        # API代理
        location /api/ {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # 超时配置
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
            
            # 缓冲配置
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
        }
        
        # WebSocket支持
        location /ws/ {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        # 文件上传
        location /uploads/ {
            alias /app/uploads/;
            expires 1d;
            add_header Cache-Control "public";
        }
        
        # 健康检查
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}
```

### 2. 前端服务配置

**前端服务编排 (docker-compose.frontend.yml):**

```yaml
version: '3.8'
services:
  nginx:
    image: nginx:1.21-alpine
    container_name: nginx-frontend
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./frontend/dist:/usr/share/nginx/html:ro
      - ./nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - ./nginx/logs:/var/log/nginx
      - ./backend/uploads:/app/uploads:ro
    depends_on:
      - backend-api
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3

networks:
  app-network:
    external: true
```

## AI服务配置

### 1. AI服务密钥管理

**环境变量配置 (.env):**

```bash
# 数据库配置
MYSQL_ROOT_PASSWORD=your_mysql_root_password
MYSQL_USER=app_user
MYSQL_PASSWORD=your_mysql_password
REPLICATION_PASSWORD=your_replication_password

# Redis配置
REDIS_PASSWORD=your_redis_password

# 应用配置
SECRET_KEY=your_secret_key_here
JWT_SECRET_KEY=your_jwt_secret_key_here

# AI服务配置
OPENAI_API_KEY=sk-your_openai_api_key
CLAUDE_API_KEY=your_claude_api_key
WENXIN_API_KEY=your_wenxin_api_key

# 文件存储配置
OSS_ACCESS_KEY_ID=your_oss_access_key
OSS_ACCESS_KEY_SECRET=your_oss_secret_key
OSS_BUCKET_NAME=your_bucket_name
OSS_ENDPOINT=your_oss_endpoint
```

### 2. AI服务限流配置

**限流配置 (backend/config/rate_limit.py):**

```python
from typing import Dict, Any

# AI服务限流配置
AI_RATE_LIMITS = {
    "openai": {
        "requests_per_minute": 60,
        "tokens_per_minute": 150000,
        "max_concurrent": 10
    },
    "claude": {
        "requests_per_minute": 50,
        "tokens_per_minute": 100000,
        "max_concurrent": 8
    },
    "wenxin": {
        "requests_per_minute": 100,
        "tokens_per_minute": 200000,
        "max_concurrent": 15
    }
}

# 用户级别限流
USER_RATE_LIMITS = {
    "teacher": {
        "ai_requests_per_hour": 200,
        "file_uploads_per_day": 50
    },
    "student": {
        "ai_requests_per_hour": 50,
        "file_uploads_per_day": 10
    },
    "admin": {
        "ai_requests_per_hour": 1000,
        "file_uploads_per_day": 200
    }
}
```

## 监控与日志

### 1. Prometheus监控配置

**Prometheus配置 (monitoring/prometheus/prometheus.yml):**

```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "rules/*.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'backend-api'
    static_configs:
      - targets: ['backend-api:8000']
    metrics_path: '/metrics'
    scrape_interval: 30s

  - job_name: 'mysql'
    static_configs:
      - targets: ['mysql-exporter:9104']

  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']

  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx-exporter:9113']

  - job_name: 'node'
    static_configs:
      - targets: ['node-exporter:9100']
```

### 2. 日志收集配置

**日志配置 (backend/config/logging.py):**

```python
import logging
import logging.handlers
from pathlib import Path

def setup_logging(log_level: str = "INFO", log_file: str = "/app/logs/app.log"):
    """配置应用日志"""
    
    # 创建日志目录
    log_path = Path(log_file)
    log_path.parent.mkdir(parents=True, exist_ok=True)
    
    # 配置根日志器
    logging.basicConfig(
        level=getattr(logging, log_level.upper()),
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            # 控制台输出
            logging.StreamHandler(),
            # 文件输出（轮转）
            logging.handlers.RotatingFileHandler(
                log_file,
                maxBytes=100*1024*1024,  # 100MB
                backupCount=10
            )
        ]
    )
    
    # 配置特定日志器
    loggers = {
        'uvicorn.access': logging.INFO,
        'sqlalchemy.engine': logging.WARNING,
        'httpx': logging.WARNING,
        'app.ai_service': logging.INFO,
        'app.auth': logging.INFO,
        'app.api': logging.INFO
    }
    
    for logger_name, level in loggers.items():
        logger = logging.getLogger(logger_name)
        logger.setLevel(level)
```

## 安全配置

### 1. SSL证书配置

**SSL证书生成脚本 (scripts/generate_ssl.sh):**

```bash
#!/bin/bash

# 创建SSL目录
mkdir -p nginx/ssl

# 生成私钥
openssl genrsa -out nginx/ssl/key.pem 2048

# 生成证书签名请求
openssl req -new -key nginx/ssl/key.pem -out nginx/ssl/cert.csr -subj "/C=CN/ST=Beijing/L=Beijing/O=School/CN=localhost"

# 生成自签名证书（开发环境）
openssl x509 -req -days 365 -in nginx/ssl/cert.csr -signkey nginx/ssl/key.pem -out nginx/ssl/cert.pem

# 设置权限
chmod 600 nginx/ssl/key.pem
chmod 644 nginx/ssl/cert.pem

echo "SSL证书生成完成"
```

### 2. 防火墙配置

**防火墙规则 (scripts/setup_firewall.sh):**

```bash
#!/bin/bash

# 启用UFW防火墙
sudo ufw --force enable

# 默认策略
sudo ufw default deny incoming
sudo ufw default allow outgoing

# 允许SSH
sudo ufw allow ssh

# 允许HTTP和HTTPS
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp

# 允许内部服务端口（仅限本地）
sudo ufw allow from 127.0.0.1 to any port 3306  # MySQL
sudo ufw allow from 127.0.0.1 to any port 6379  # Redis
sudo ufw allow from 127.0.0.1 to any port 8000  # Backend API

# 显示状态
sudo ufw status verbose

echo "防火墙配置完成"
```

## 性能优化

### 1. 数据库优化

**数据库优化脚本 (scripts/optimize_database.sql):**

```sql
-- 分析表统计信息
ANALYZE TABLE users, students, grade_records, classroom_sessions;

-- 优化表
OPTIMIZE TABLE system_logs, ai_chat_messages;

-- 检查索引使用情况
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,
    SUB_PART,
    NULLABLE
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'intelligent_teaching_assistant'
ORDER BY TABLE_NAME, INDEX_NAME;

-- 检查慢查询
SELECT 
    query_time,
    lock_time,
    rows_sent,
    rows_examined,
    sql_text
FROM mysql.slow_log 
WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 DAY)
ORDER BY query_time DESC
LIMIT 10;
```

### 2. 应用性能优化

**性能监控中间件 (backend/app/middleware/performance.py):**

```python
import time
import logging
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

logger = logging.getLogger(__name__)

class PerformanceMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
        
        # 记录请求信息
        logger.info(f"Request: {request.method} {request.url}")
        
        # 处理请求
        response = await call_next(request)
        
        # 计算处理时间
        process_time = time.time() - start_time
        
        # 添加响应头
        response.headers["X-Process-Time"] = str(process_time)
        
        # 记录慢请求
        if process_time > 1.0:  # 超过1秒的请求
            logger.warning(
                f"Slow request: {request.method} {request.url} "
                f"took {process_time:.2f}s"
            )
        
        return response
```

## 故障排除

### 1. 常见问题诊断

**健康检查脚本 (scripts/health_check.sh):**

```bash
#!/bin/bash

echo "=== 智能教学助手2.0 健康检查 ==="
echo

# 检查容器状态
echo "1. 检查容器状态:"
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
echo

# 检查数据库连接
echo "2. 检查数据库连接:"
if docker exec mysql-master mysqladmin ping -h localhost --silent; then
    echo "✓ MySQL主库连接正常"
else
    echo "✗ MySQL主库连接失败"
fi

if docker exec mysql-slave mysqladmin ping -h localhost --silent; then
    echo "✓ MySQL从库连接正常"
else
    echo "✗ MySQL从库连接失败"
fi
echo

# 检查Redis连接
echo "3. 检查Redis连接:"
if docker exec redis-master redis-cli ping | grep -q PONG; then
    echo "✓ Redis主库连接正常"
else
    echo "✗ Redis主库连接失败"
fi
echo

# 检查API服务
echo "4. 检查API服务:"
if curl -f http://localhost:8000/health >/dev/null 2>&1; then
    echo "✓ 后端API服务正常"
else
    echo "✗ 后端API服务异常"
fi
echo

# 检查前端服务
echo "5. 检查前端服务:"
if curl -f http://localhost/health >/dev/null 2>&1; then
    echo "✓ 前端服务正常"
else
    echo "✗ 前端服务异常"
fi
echo

# 检查磁盘空间
echo "6. 检查磁盘空间:"
df -h | grep -E '(Filesystem|/dev/)'
echo

# 检查内存使用
echo "7. 检查内存使用:"
free -h
echo

echo "健康检查完成"
```

### 2. 日志分析脚本

**日志分析脚本 (scripts/analyze_logs.sh):**

```bash
#!/bin/bash

LOG_DIR="/opt/intelligent-teaching-assistant"
DATE=${1:-$(date +%Y-%m-%d)}

echo "=== 日志分析报告 ($DATE) ==="
echo

# 分析API访问日志
echo "1. API访问统计:"
grep "$DATE" $LOG_DIR/nginx/logs/access.log | \
    awk '{print $7}' | sort | uniq -c | sort -nr | head -10
echo

# 分析错误日志
echo "2. 错误统计:"
grep "ERROR" $LOG_DIR/backend/logs/app.log | \
    grep "$DATE" | wc -l
echo "今日错误数量: $(grep "ERROR" $LOG_DIR/backend/logs/app.log | grep "$DATE" | wc -l)"
echo

# 分析慢查询
echo "3. 慢查询统计:"
grep "Slow request" $LOG_DIR/backend/logs/app.log | \
    grep "$DATE" | wc -l
echo "今日慢查询数量: $(grep "Slow request" $LOG_DIR/backend/logs/app.log | grep "$DATE" | wc -l)"
echo

# 分析AI服务调用
echo "4. AI服务调用统计:"
grep "AI request" $LOG_DIR/backend/logs/app.log | \
    grep "$DATE" | wc -l
echo "今日AI调用数量: $(grep "AI request" $LOG_DIR/backend/logs/app.log | grep "$DATE" | wc -l)"
echo

echo "日志分析完成"
```

### 3. 备份恢复脚本

**数据备份脚本 (scripts/backup.sh):**

```bash
#!/bin/bash

BACKUP_DIR="/opt/intelligent-teaching-assistant/database/backup"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/backup_$DATE.sql"

# 创建备份目录
mkdir -p $BACKUP_DIR

echo "开始数据库备份..."

# 备份数据库
docker exec mysql-master mysqldump \
    --single-transaction \
    --routines \
    --triggers \
    --all-databases \
    -uroot -p$MYSQL_ROOT_PASSWORD > $BACKUP_FILE

if [ $? -eq 0 ]; then
    echo "数据库备份成功: $BACKUP_FILE"
    
    # 压缩备份文件
    gzip $BACKUP_FILE
    echo "备份文件已压缩: $BACKUP_FILE.gz"
    
    # 删除7天前的备份
    find $BACKUP_DIR -name "backup_*.sql.gz" -mtime +7 -delete
    echo "已清理7天前的备份文件"
else
    echo "数据库备份失败"
    exit 1
fi

echo "备份完成"
```

---

## 部署检查清单

### 部署前检查
- [ ] 服务器资源充足（CPU、内存、磁盘）
- [ ] 网络连接正常
- [ ] Docker和Docker Compose已安装
- [ ] 环境变量已配置
- [ ] SSL证书已准备
- [ ] 防火墙规则已设置

### 部署过程检查
- [ ] 数据库服务启动正常
- [ ] Redis服务启动正常
- [ ] 后端API服务启动正常
- [ ] 前端服务启动正常
- [ ] 健康检查通过
- [ ] 日志输出正常

### 部署后检查
- [ ] 用户可以正常访问系统
- [ ] 登录功能正常
- [ ] AI服务调用正常
- [ ] 文件上传下载正常
- [ ] 数据库读写正常
- [ ] 监控指标正常
- [ ] 备份策略已启用

---

**注意事项：**
1. 生产环境部署前请充分测试
2. 定期检查系统健康状态
3. 及时更新安全补丁
4. 保持数据备份的完整性
5. 监控系统性能指标
6. 建立应急响应机制

如有问题，请参考故障排除章节或联系技术支持团队。